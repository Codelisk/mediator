using System.Text;
using Humanizer;
using Microsoft.OpenApi.Models;
using Microsoft.OpenApi.Readers;

namespace Shiny.Mediator.HttpRequestGenerator;

public class ContractGenerator
{
    // https://github.com/christianhelle/refitter/tree/main/src/Refitter.Core
    // TODO: loop through, generate all types and enums - keep a list of full ref name along with Pascal generated name
    // TODO: generate each contract for each operation
    public void Test(Stream stream, string writePath, string nameSpace, string className)
    {
        // TODO: may need to keep a list of generated types
        // var types = new List<string>();
        
        using var streamReader = new StreamReader(stream);
        var reader = new OpenApiStreamReader();
        var document = reader.Read(streamReader.BaseStream, out var diagnostic);
        if (diagnostic.Errors != null && diagnostic.Errors.Count > 0)
        {
            foreach (var e in diagnostic.Errors)
                Console.WriteLine("Error reading OpenAPI document");
            return;
        }

        var types = new StringBuilder();
        
        var sb = new StringBuilder();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// This file is generated by Shiny.Mediator.HttpRequestGenerator");
        sb.AppendLine("/// Do not modify this file directly");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine();
        sb.AppendLine($"namespace {nameSpace};");
        sb.AppendLine();
        
        foreach (var schema in document.Components.Schemas)
        {
            // TODO: temp
            if (schema.Value.Type == null)
                continue;
            
            var type = this.GenerateComplexTypeIfNeeded(schema);
            sb.Append(type);
            sb.AppendLine();
        }
        
        sb.AppendLine($"public class {className}");
        sb.AppendLine("{");
        // TODO: additional properties
        foreach (var path in document.Paths)
        {
            // path.Key
            foreach (var op in path.Value.Operations)
            {
                // TODO: the operation === the contract
                // TODO: if no operationId, toss exception
                var contractSb = new StringBuilder();

                // TODO: if no response, add Shiny.Mediator.Unit
                contractSb.AppendLine($"public class {op.Value.OperationId.Pascalize()} : Shiny.Mediator.Http.IHttpRequest<TODO: NEED 200 RESPONSE>");
                contractSb.AppendLine("{");
                foreach (var parameter in op.Value.Parameters)
                {
                    if (parameter.Schema != null)
                    {
                        var typeName = this.GetAndCreateTypeIfNeeded(new KeyValuePair<string, OpenApiSchema>(parameter.Name, parameter.Schema));
                        var propertyName = parameter.Name.Pascalize();
                        contractSb.AppendLine($"    public {typeName} {propertyName} {{ get; set; }}");
                    }
                }
                contractSb.AppendLine("}");
                
                // op.Key == OperationType.Get
                // op.Value.OperationId // camel case
                if (!op.Value.Responses.TryGetValue("200", out var response))
                {
                    // TODO: no success response
                }
                else
                {
                    // if (op.Value.RequestBody.Content == null)
                    // {
                    // }

                    op.Value.RequestBody?.Content.TryGetValue("application/json", out var bodyContent);
                    foreach (var parameter in op.Value.Parameters)
                    {
                        // parameter.In == ParameterLocation.Path
                        // parameter.In == ParameterLocation.Query
                        
                        
                    }

                    // response.Description - comment
                    if (!response.Content.TryGetValue("application/json", out var content))
                    {
                        // TODO: no json response
                    }
                    else
                    {
                        // response.Headers
                        
                        // TODO: ENUMS
                        // content.Schema.AllOf - need to generate an enum on the namespace
                        foreach (var property in content.Schema.Properties)
                        {
                            var pname = property.Key;
                            sb.AppendLine("");
                            // property.Key
                            // property.Value.AllOf - need to generate an enum on the namespace
                        }
                    }
                }
            }
        }

        if (!Directory.Exists(writePath))
            Directory.CreateDirectory(writePath);
        
        var filePath = Path.Combine(writePath, $"{className}.generated.cs");
        File.WriteAllText(filePath, sb.ToString());
    }

    
    string GetAndCreateTypeIfNeeded(KeyValuePair<string, OpenApiSchema> schema)
    {
        var typeName = schema.Value.Type switch
        {
            "string" => GetStringType(schema.Value),
            "integer" => GetNumberType(schema.Value.Format),
            "number" => GetNumberType(schema.Value.Format),
            "boolean" => "bool",
            "object" => "object",

            "array" => "array", // TODO
            _ => "INVALID SCHEMA TYPE"
            // _ => throw new InvalidOperationException("Invalid Type - " + schema.Type)
        };
        if (typeName == "object")
        {
        }
        if (schema.Value.Nullable)
            typeName += "?";

        return typeName;
    }

    static string GetStringType(OpenApiSchema schema) => schema.Type switch
    {
        "date-time" => "System.DateTimeOffset",
        "uuid" => "System.Guid",
        
        // TODO: format can be enum which needs to be generated
        // "enum" => "enum", // TODO: generate enum from schema.Enum (string array)
        _ => "string"
    };

    static string GetNumberType(string format) => format switch
    {
        "int32" => "int",
        "int64" => "long",
        "float" => "float",
        "double" => "double",
        _ => "INVALID"
    };


    // readonly List<string> generatedTypes = new();
    string GenerateComplexTypeIfNeeded(KeyValuePair<string, OpenApiSchema> schema)
    {
        // if (this.generatedTypes.Contains(schema.Type))
        //     this.generatedTypes.Add(schema.Type);

        var sb = new StringBuilder();
        var className = schema.Key.Pascalize();
        // TODO: schema.AllOf <= ARRAY
        sb.AppendLine("public class " + className);
        sb.AppendLine("{");
        
        foreach (var prop in schema.Value.Properties)
        {
            var propertyName = prop.Key.Pascalize();
            if (prop.Value != null)
            {
                if (prop.Value.Type == null)
                    continue;
                
                // TODO: allOf == type is null
                var typeName = this.GetAndCreateTypeIfNeeded(prop);

                sb.AppendLine($"    [JsonPropertyName(\"{prop.Key}\")]");
                sb.AppendLine("    public " + typeName + " " + propertyName + " { get; set; }");
                sb.AppendLine();
            }
        }
        sb.AppendLine("}");
        return sb.ToString();
    }
}