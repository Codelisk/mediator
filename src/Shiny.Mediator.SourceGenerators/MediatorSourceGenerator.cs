using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Shiny.Mediator.SourceGenerators;

[Generator(LanguageNames.CSharp)]
public class MediatorSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register post initialization to generate attributes
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "MediatorAttributes.g.cs",
            SourceText.From(
                """
                // <auto-generated>
                // Code generated by Shiny Mediator Source Generator.
                // Changes may cause incorrect behavior and will be lost if the code is
                // regenerated.
                // </auto-generated>
                #nullable disable
                
                $GENCODEATTRIBUTE$
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                internal sealed class SingletonHandlerAttribute : global::System.Attribute
                {
                }
                
                $GENCODEATTRIBUTE$
                [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = false)]
                internal sealed class ScopedHandlerAttribute : global::System.Attribute
                {
                }
                """.Replace("$GENCODEATTRIBUTE$", Constants.GeneratedCodeAttributeString),
                Encoding.UTF8
            )
        ));

        // Create provider for classes with handler attributes
        var classesProvider = context.SyntaxProvider
            .CreateSyntaxProvider<INamedTypeSymbol?>(
                predicate: static (s, _) => IsCandidateNode(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null)
            .Collect();

        // Create provider for MSBuild properties
        var configProvider = context.AnalyzerConfigOptionsProvider;

        // Combine providers
        var combined = classesProvider
            .Combine(context.CompilationProvider)
            .Combine(configProvider);

        // Register source output
        context.RegisterSourceOutput(combined, static (spc, source) => Execute(spc, source));
    }

    static bool IsCandidateNode(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration && 
               classDeclaration.AttributeLists.Count > 0;
    }

    static INamedTypeSymbol? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;
        
        if (symbol == null)
            return null;

        // Skip Shiny.Mediator assembly classes
        if (symbol.ContainingAssembly.Name.StartsWith("Shiny.Mediator", StringComparison.CurrentCultureIgnoreCase))
            return null;
        
        // Check if class has handler attributes
        var hasAttribute = HasAttribute(symbol, "SingletonHandlerAttribute") ||
                          HasAttribute(symbol, "ScopedHandlerAttribute");
        
        return hasAttribute ? symbol : null;
    }

    static bool HasAttribute(INamedTypeSymbol symbol, string attributeName)
    {
        return symbol.GetAttributes().Any(attr => 
            attr.AttributeClass?.Name == attributeName ||
            attr.AttributeClass?.ToDisplayString().EndsWith(attributeName) == true);
    }

    static void Execute(SourceProductionContext context, ((ImmutableArray<INamedTypeSymbol?> Classes, Compilation Compilation) Left, Microsoft.CodeAnalysis.Diagnostics.AnalyzerConfigOptionsProvider ConfigOptions) input)
    {
        var ((classes, compilation), configOptions) = input;

        // Check if source generation is disabled
        var globalOptions = configOptions.GlobalOptions;
        if (globalOptions.TryGetValue("build_property.ShinyMediatorDisableSourceGen", out var skipValue) &&
            skipValue.Equals("true", StringComparison.InvariantCultureIgnoreCase))
            return;

        // Filter out null values and deduplicate
        var validClasses = classes
            .Where(c => c is not null)
            .GroupBy(x => x!.ToDisplayString())
            .Select(x => x.First()!)
            .ToList();

        if (!validClasses.Any())
            return;

        // Get namespace and assembly name
        globalOptions.TryGetValue("build_property.RootNamespace", out var nameSpace);
        nameSpace ??= compilation.AssemblyName;
        
        var assName = compilation.AssemblyName?.Replace(".", "_");
        
        var sb = new StringBuilder();
        sb
            .AppendLine("using Shiny.Mediator;")
            .AppendLine()
            .AppendLine($"namespace {nameSpace};")
            .AppendLine()
            .AppendLine(Constants.GeneratedCodeAttributeString)
            .AppendLine("public static class __ShinyMediatorSourceGenExtensions {")
            .AppendLine($"\tpublic static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddDiscoveredMediatorHandlersFrom{assName}(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection services)")
            .AppendLine("\t{");

        foreach (var clazz in validClasses)
        {
            var cls = clazz.ToDisplayString();
            if (HasAttribute(clazz, "ScopedHandlerAttribute") || HasAttribute(clazz, "ScopedMiddlewareAttribute"))
                sb.AppendLine($"\t\tservices.AddScopedAsImplementedInterfaces<{cls}>();");
            else
                sb.AppendLine($"\t\tservices.AddSingletonAsImplementedInterfaces<{cls}>();");
        }

        sb
            .AppendLine("\t\treturn services;")
            .AppendLine("\t}")
            .AppendLine("}");

        context.AddSource("__MediatorHandlersRegistration.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}