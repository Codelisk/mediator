using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.Text;

namespace Shiny.Mediator.SourceGenerators;


[Generator(LanguageNames.CSharp)]
public class JsonConverterSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(x =>
        {
            x.AddSource(
                "SourceGenerateJsonConverterAttribute.g.cs",
                """
                // <auto-generated/>
                using System;

                [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
                internal sealed class SourceGenerateJsonConverterAttribute : Attribute;
                """
            );
        });

        // Find all types marked with SourceGenerateJsonConverter attribute
        var typesToGenerate = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "SourceGenerateJsonConverterAttribute",
                predicate: static (node, _) => node is TypeDeclarationSyntax,
                transform: static (context, _) => GetTypeInfo(context)
            )
            .Where(static x => x is not null);

        context.RegisterSourceOutput(typesToGenerate.Collect(), static (context, types) =>
        {
            foreach (var typeInfo in types)
            {
                if (typeInfo != null)
                {
                    // Check if class is partial (structs don't need to be partial)
                    if (typeInfo.IsClass && !typeInfo.IsPartial)
                    {
                        var diagnostic = Diagnostic.Create(
                            new DiagnosticDescriptor(
                                "SJSG001",
                                "Class must be partial",
                                "Class '{0}' marked with SourceGenerateJsonConverter must be declared as partial",
                                "JsonSourceGenerator",
                                DiagnosticSeverity.Error,
                                true
                            ),
                            typeInfo.Location,
                            typeInfo.Name
                        );
                        
                        context.ReportDiagnostic(diagnostic);
                    }
                    else
                    {
                        GenerateJsonConverter(context, typeInfo);
                        GeneratePartialTypeWithAttribute(context, typeInfo);
                    }
                }
            }
        });
    }

    private static TypeInfo? GetTypeInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetNode is not TypeDeclarationSyntax typeDeclaration)
            return null;

        var typeSymbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration);
        if (typeSymbol is null)
            return null;

        var properties = typeSymbol
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Where(x => 
                x.DeclaredAccessibility == Accessibility.Public && 
                x.GetMethod != null && 
                x.SetMethod != null
            )
            .Select(x => new PropertyInfo(
                x.Name,
                x.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                x.Type.CanBeReferencedByName,
                IsNullableType(x.Type)
            ))
            .ToArray();

        // Check if the type is partial
        var isPartial = typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        
        return new TypeInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace?.ToDisplayString() ?? "",
            typeDeclaration.IsKind(SyntaxKind.ClassDeclaration),
            isPartial,
            properties,
            typeDeclaration.GetLocation()
        );
    }

    private static bool IsNullableType(ITypeSymbol type)
    {
        // Check if it's a nullable value type (e.g., int?, DateTime?)
        if (type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
            return true;

        // For reference types, they are inherently nullable in C#
        // Even without explicit nullable annotations, strings and other reference types can be null
        if (type.IsReferenceType)
        {
            return true; // All reference types can be null
        }

        return false;
    }


    public static void GenerateJsonConverter(SourceProductionContext context, INamedTypeSymbol typeSymbol)
    {
        // Get the syntax node for the type symbol to check if it's partial
        var syntaxReferences = typeSymbol.DeclaringSyntaxReferences;
        if (!syntaxReferences.Any())
            return;

        var typeDeclaration = syntaxReferences.First().GetSyntax() as TypeDeclarationSyntax;
        if (typeDeclaration == null)
            return;

        // Extract type information
        var properties = typeSymbol
            .GetMembers()
            .OfType<IPropertySymbol>()
            .Where(x => 
                x.DeclaredAccessibility == Accessibility.Public && 
                x.GetMethod != null && 
                x.SetMethod != null
            )
            .Select(x => new PropertyInfo(
                x.Name,
                x.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                x.Type.CanBeReferencedByName,
                IsNullableType(x.Type)
            ))
            .ToArray();

        // Check if the type is partial
        var isPartial = typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
        var isClass = typeSymbol.TypeKind == TypeKind.Class;

        var typeInfo = new TypeInfo(
            typeSymbol.Name,
            typeSymbol.ContainingNamespace?.ToDisplayString() ?? "",
            isClass,
            isPartial,
            properties,
            typeDeclaration.GetLocation()
        );

        // Validate that classes are partial (structs don't need to be partial)
        if (typeInfo.IsClass && !typeInfo.IsPartial)
        {
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    "SJSG001",
                    "Class must be partial",
                    "Class '{0}' marked with SourceGenerateJsonConverter must be declared as partial",
                    "JsonSourceGenerator",
                    DiagnosticSeverity.Error,
                    true
                ),
                typeInfo.Location,
                typeInfo.Name
            );
            context.ReportDiagnostic(diagnostic);
        }
        else
        {
            GenerateJsonConverter(context, typeInfo);
            GeneratePartialTypeWithAttribute(context, typeInfo);
        }
    }
    

    private static void GeneratePartialTypeWithAttribute(SourceProductionContext context, TypeInfo typeInfo)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("/// <auto-generated>");
        sb.AppendLine("/// This code was generated by Shiny.Json.SourceGenerator");
        sb.AppendLine("/// </auto-generated>");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine();

        if (!String.IsNullOrEmpty(typeInfo.Namespace))
        {
            sb.AppendLine($"namespace {typeInfo.Namespace};");
            sb.AppendLine();
        }

        var typeKeyword = typeInfo.IsClass ? "class" : "struct";
        var partialKeyword = typeInfo.IsClass ? "partial " : "";
        
        sb.AppendLine($"[global::System.Text.Json.Serialization.JsonConverter(typeof({typeInfo.Name}JsonConverter))]");
        sb.AppendLine($"{partialKeyword}{typeKeyword} {typeInfo.Name}");
        sb.AppendLine("{");
        sb.AppendLine("}");

        var ns = String.Empty;
        if (!String.IsNullOrWhiteSpace(typeInfo.Namespace) && !typeInfo.Namespace.Contains("<"))
            ns = typeInfo.Namespace + ".";
        
        context.AddSource($"{ns}{typeInfo.Name}.JsonConverterAttribute.g.cs", sb.ToString());
    }
    

    private static void GenerateJsonConverter(SourceProductionContext context, TypeInfo typeInfo)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(typeInfo.Namespace))
        {
            sb.AppendLine($"namespace {typeInfo.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"public sealed class {typeInfo.Name}JsonConverter : JsonConverter<{typeInfo.Name}>");
        sb.AppendLine("{");

        // Write method
        sb.AppendLine($"    public override void Write(Utf8JsonWriter writer, {typeInfo.Name} value, JsonSerializerOptions options)");
        sb.AppendLine("    {");

        // For structs, we don't need null checks on the main value
        if (typeInfo.IsClass)
        {
            sb.AppendLine("        if (value == null)");
            sb.AppendLine("        {");
            sb.AppendLine("            writer.WriteNullValue();");
            sb.AppendLine("            return;");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
        
        sb.AppendLine("        writer.WriteStartObject();");
        
        foreach (var prop in typeInfo.Properties)
        {
            sb.AppendLine($"        writer.WritePropertyName(\"{prop.Name}\");");
            if (prop.IsNullable)
            {
                sb.AppendLine($"        if (value.{prop.Name} == null)");
                sb.AppendLine("            writer.WriteNullValue();");
                sb.AppendLine("        else");
                sb.AppendLine($"            JsonSerializer.Serialize(writer, value.{prop.Name}, options);");
            }
            else
            {
                sb.AppendLine($"        JsonSerializer.Serialize(writer, value.{prop.Name}, options);");
            }
        }
        
        sb.AppendLine("        writer.WriteEndObject();");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Read method
        string returnType = typeInfo.IsClass ? $"{typeInfo.Name}?" : typeInfo.Name;
        sb.AppendLine($"    public override {returnType} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (reader.TokenType == JsonTokenType.Null)");
        if (typeInfo.IsClass)
        {
            sb.AppendLine("            return null;");
        }
        else
        {
            sb.AppendLine($"            throw new JsonException(\"Cannot deserialize null to struct {typeInfo.Name}\");");
        }
        sb.AppendLine();
        sb.AppendLine("        if (reader.TokenType != JsonTokenType.StartObject)");
        sb.AppendLine("            throw new JsonException(\"Expected StartObject token\");");
        sb.AppendLine();
        
        sb.AppendLine($"        var result = new {typeInfo.Name}();");
        
        sb.AppendLine();
        sb.AppendLine("        while (reader.Read())");
        sb.AppendLine("        {");
        sb.AppendLine("            if (reader.TokenType == JsonTokenType.EndObject)");
        sb.AppendLine("                break;");
        sb.AppendLine();
        sb.AppendLine("            if (reader.TokenType != JsonTokenType.PropertyName)");
        sb.AppendLine("                throw new JsonException(\"Expected PropertyName token\");");
        sb.AppendLine();
        sb.AppendLine("            var propertyName = reader.GetString();");
        sb.AppendLine("            reader.Read();");
        sb.AppendLine();
        sb.AppendLine("            switch (propertyName)");
        sb.AppendLine("            {");

        foreach (var prop in typeInfo.Properties)
        {
            sb.AppendLine($"                case \"{prop.Name}\":");
            if (prop.IsNullable)
            {
                sb.AppendLine("                    if (reader.TokenType == JsonTokenType.Null)");
                sb.AppendLine($"                        result.{prop.Name} = null;");
                sb.AppendLine("                    else");
                sb.AppendLine($"                        result.{prop.Name} = JsonSerializer.Deserialize<{prop.TypeName}>(ref reader, options);");
            }
            else
            {
                sb.AppendLine("                    if (reader.TokenType == JsonTokenType.Null)");
                sb.AppendLine($"                        throw new JsonException(\"Cannot assign null to non-nullable property '{prop.Name}'\");");
                sb.AppendLine($"                    result.{prop.Name} = JsonSerializer.Deserialize<{prop.TypeName}>(ref reader, options)!;");
            }
            sb.AppendLine("                    break;");
        }

        sb.AppendLine("                default:");
        sb.AppendLine("                    reader.Skip();");
        sb.AppendLine("                    break;");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return result;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        var ns = String.Empty;
        if (!String.IsNullOrWhiteSpace(typeInfo.Namespace) && !typeInfo.Namespace.Contains("<"))
            ns = typeInfo.Namespace + ".";
        
        context.AddSource($"{ns}{typeInfo.Name}JsonConverter.g.cs", sb.ToString());
    }

    class TypeInfo
    {
        public TypeInfo(string name, string @namespace, bool isClass, bool isPartial, PropertyInfo[] properties, Location location)
        {
            Name = name;
            Namespace = @namespace;
            IsClass = isClass;
            IsPartial = isPartial;
            Properties = properties;
            Location = location;
        }

        public string Name { get; }
        public string Namespace { get; }
        public bool IsClass { get; }
        public bool IsPartial { get; }
        public PropertyInfo[] Properties { get; }
        public Location Location { get; }
    }

    class PropertyInfo
    {
        public PropertyInfo(string name, string typeName, bool canBeReferenced, bool isNullable)
        {
            Name = name;
            TypeName = typeName;
            CanBeReferenced = canBeReferenced;
            IsNullable = isNullable;
        }

        public string Name { get; }
        public string TypeName { get; }
        public bool CanBeReferenced { get; }
        public bool IsNullable { get; }
    }
}