using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.OpenApi.Any;
using Microsoft.OpenApi.Models;
using Microsoft.OpenApi.Readers;

namespace Shiny.Mediator.SourceGenerators.Http;


public class OpenApiContractGenerator(MediatorHttpItemConfig itemConfig, Action<string, DiagnosticSeverity> output)
{
    readonly StringBuilder typeBuilder = new();
    readonly StringBuilder contractBuilder = new();
    readonly StringBuilder converterBuilder = new();
    readonly HashSet<string> typesNeedingConverters = new();
    readonly Dictionary<string, OpenApiSchema> schemaCache = new();
    string accessorType = "public";
    
    public string Generate(Stream stream)
    {
        if (itemConfig.UseInternalClasses)
            this.accessorType = "internal";
        
        this.typeBuilder.Clear();
        this.contractBuilder.Clear();
        this.converterBuilder.Clear();
        this.typesNeedingConverters.Clear();
        this.schemaCache.Clear();
        
        using var streamReader = new StreamReader(stream);
        var reader = new OpenApiStreamReader();
        var document = reader.Read(streamReader.BaseStream, out var diagnostic);
        if (document == null)
            throw new InvalidOperationException("OpenApi Document is null");
        
        if (diagnostic.Errors is { Count: > 0 })
        {
            var e = diagnostic.Errors.First();
            throw new InvalidOperationException($"OpenApi Error: {e.Message} - {e.Pointer}");
        }
        
        this.typeBuilder.AppendLine("/// <summary>");
        this.typeBuilder.AppendLine("/// This file is generated by Shiny.Mediator source generation");
        this.typeBuilder.AppendLine("/// Do not modify this file directly");
        this.typeBuilder.AppendLine("/// </summary>");
        this.typeBuilder.AppendLine("#nullable enable");
        this.typeBuilder.AppendLine();
        this.typeBuilder.AppendLine($"namespace {itemConfig.Namespace};");
        this.typeBuilder.AppendLine();
        
        this.GenerateComponents(document);
        if (!itemConfig.GenerateModelsOnly) 
            this.GenerateContracts(document);
        
        var result = this.typeBuilder.ToString() + this.contractBuilder.ToString() + this.converterBuilder.ToString();
        return result;
    }


    void GenerateComponents(OpenApiDocument document)
    {
        output("Generating Components for " + itemConfig.Namespace, DiagnosticSeverity.Info);
        if (document.Components?.Schemas != null)
        {
            foreach (var schema in document.Components.Schemas)
            {
                this.GenerateComplexType(schema);
            }
        }
    }


    void GenerateContracts(OpenApiDocument document)
    {
        foreach (var path in document.Paths)
        {
            output("PATH: " + path.Key, DiagnosticSeverity.Info);
            
            foreach (var op in path.Value.Operations)
            {
                if (String.IsNullOrWhiteSpace(op.Value.OperationId))
                {
                    output("NO OPERATION ID on " + op.Key, DiagnosticSeverity.Warning);
                    continue;
                }
                output($"OPERATION: {op.Key} - ID: {op.Value.OperationId}", DiagnosticSeverity.Info);
                var responseType = this.GetResponseType(op.Value);
                output($"RESPONSE: {responseType}", DiagnosticSeverity.Info);
                
                var contractName = $"{itemConfig.ContractPrefix}{op.Value.OperationId.Pascalize()}{itemConfig.ContractPostfix}";
                var httpMethod = op.Key.ToString();
                
                this.contractBuilder
                    //.AppendLine(Constants.GeneratedCodeAttributeString)
                    .AppendLine($"[global::Shiny.Mediator.Http.HttpAttribute(global::Shiny.Mediator.Http.HttpVerb.{httpMethod}, \"{path.Key}\")]")
                    .AppendLine($"{this.accessorType} partial class {contractName} : global::Shiny.Mediator.Http.IHttpRequest<{responseType}>")
                    .AppendLine("{");
                
                foreach (var parameter in op.Value.Parameters)
                {
                    var argType = parameter.In == ParameterLocation.Path ? "Path" : "Query";
                    var typeName = this.GetSchemaType(parameter.Schema);
                    var propertyName = parameter.Name.Pascalize();
                    this.contractBuilder.AppendLine($"    [global::Shiny.Mediator.Http.HttpParameterAttribute(global::Shiny.Mediator.Http.HttpParameterType.{argType}, \"{parameter.Name}\")]");
                    this.contractBuilder.AppendLine($"    public {typeName} {propertyName} {{ get; set; }}");
                    this.contractBuilder.AppendLine();
                    output($"PROPERTY: {propertyName} ({typeName} - {argType})", DiagnosticSeverity.Info);
                }

                if (op.Value.RequestBody != null)
                {
                    var body = op.Value.RequestBody;
                    var bodyResponseType = this.GetApplicationJsonResponse(body.Content);
                    if (bodyResponseType != null)
                    {
                        // Track request body types for JSON converter generation only if enabled
                        if (itemConfig.GenerateJsonConverters)
                        {
                            var cleanType = bodyResponseType.TrimEnd('?');
                            if (cleanType.StartsWith($"global::{itemConfig.Namespace}."))
                            {
                                var typeName = cleanType.Substring($"global::{itemConfig.Namespace}.".Length);
                                this.typesNeedingConverters.Add(typeName);
                            }
                        }
                        
                        if (!body.Required)
                            bodyResponseType += "?";
                        
                        this.contractBuilder.AppendLine($"    [global::Shiny.Mediator.Http.HttpParameter(global::Shiny.Mediator.Http.HttpParameterType.Body)]");
                        this.contractBuilder.AppendLine($"    public {bodyResponseType} Body {{ get; set; }}");
                        output("BODY: " + bodyResponseType, DiagnosticSeverity.Info);
                    }
                }
                this.contractBuilder.AppendLine("}");
                this.contractBuilder.AppendLine();
            }
        }
    }
    

    string GetResponseType(OpenApiOperation op)
    {
        var responseType = "global::System.Net.Http.HttpResponseMessage";
        if (op.Responses.TryGetValue("200", out var response200))
        {
            var appJsonType = this.GetApplicationJsonResponse(response200.Content);
            if (appJsonType != null)
            {
                responseType = appJsonType;
                // Track response types for JSON converter generation only if enabled
                if (itemConfig.GenerateJsonConverters)
                {
                    var cleanResponseType = appJsonType.TrimEnd('?');
                    if (cleanResponseType.StartsWith($"global::{itemConfig.Namespace}."))
                    {
                        var typeName = cleanResponseType.Substring($"global::{itemConfig.Namespace}.".Length);
                        this.typesNeedingConverters.Add(typeName);
                    }
                }
            }
        }

        return responseType;
    }
    

    string? GetApplicationJsonResponse(IDictionary<string, OpenApiMediaType> response)
    {
        string? responseType = null;
        if (response.TryGetValue("application/json", out var responseContent))
            responseType = this.GetSchemaType(responseContent.Schema);

        return responseType;
    }


    string? GetSchemaType(OpenApiSchema schema)
    {
        string type = null!;
        if (schema.Type != null)
        {
            switch (schema.Type)
            {
                case "string":
                    if ((schema.Enum?.Count ?? 0) == 0)
                    {
                        type = GetStringType(schema);
                    }
                    else
                    {
                        if (schema.Reference == null)
                            throw new InvalidOperationException("Enum reference is null");
                            
                        type = $"global::{itemConfig.Namespace}.{schema.Reference.Id}";
                    }
                    break;

                case "integer":
                case "number":
                    type = GetNumberType(schema.Format);
                    break;

                case "boolean":
                    type = "bool";
                    break;

                case "array":
                    var listType = this.GetSchemaType(schema.Items);
                    return $"global::System.Collections.Generic.List<{listType}>";

                case "file":
                    return "global::System.IO.Stream";
                
                case "object":
                    if (schema.AdditionalProperties == null)
                    {
                        if (schema.Reference == null)
                            throw new InvalidOperationException("Object reference is null");
                            
                        type = $"global::{itemConfig.Namespace}.{schema.Reference.Id}";    
                    }
                    else
                    {
                        var dictionaryValueType = this.GetSchemaType(schema.AdditionalProperties);
                        type = $"global::System.Collections.Generic.Dictionary<string, {dictionaryValueType}>";
                    }
                    break;

                default:
                    throw new InvalidOperationException("Invalid type - " + schema.Type);
            }
        }
        // TODO: we're not ready for more than 1 right now
        else if ((schema.AllOf?.Count ?? 0) == 1)
        {
            // if discriminator is present, 2 will come through which means the following will error
            // we want to return null instead
            type = this.GetSchemaType(schema.AllOf!.Single()!)!;
        }
        else
        {
            return null;
        }

        if (schema.Nullable)
            type += "?";
        
        return type;
    }


    static string GetStringType(OpenApiSchema schema)
    {
        if (schema.Pattern?.Equals("^-?(\\d+\\.)?\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,7})?$") ?? false)
            return "System.TimeSpan";
        
        return schema.Format switch
        {
            "date-time" => "System.DateTimeOffset",
            "uuid" => "System.Guid",
            "date" => "System.DateOnly",
            "time" => "System.TimeOnly",
            "date-span" => "System.TimeSpan",
            // "binary" => "byte[]",
            // "file" => "",
            _ => "string"
        };
    }


    static string GetNumberType(string format) => format switch
    {
        "int32" => "int",
        "int64" => "long",
        "float" => "float",
        "double" => "double",
        null => "double",
        _ => throw new InvalidOperationException("Invalid Number Format - " + format)
    };
    
    
    void GenerateComplexType(KeyValuePair<string, OpenApiSchema> schema)
    {
        output("COMPONENT: " + schema.Key, DiagnosticSeverity.Info);
        var className = schema.Key.Pascalize();

        if (schema.Value.Enum.Count > 0)
        {
            var add = this.GenerateEnum(schema.Value, className);
            this.typeBuilder.AppendLine(add);
        }
        else
        {
            var add = this.GenerateObject(schema.Value, className);
            this.typeBuilder.AppendLine(add);
        }
    }


    string GenerateEnum(OpenApiSchema schema, string enumName)
    {
        // https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/customize-properties?pivots=dotnet-8-0
        //[JsonConverter(typeof(JsonStringEnumConverter<TYPE>))]        
        output("ENUM COMPONENT GENERATING - " + enumName, DiagnosticSeverity.Info);

        var sb = new StringBuilder();
        sb
            //.AppendLine(Constants.GeneratedCodeAttributeString)
            .AppendLine($"{this.accessorType} enum {enumName}")
            .AppendLine("{");
        
        foreach (var ev in schema.Enum.OfType<OpenApiString>())
        {
            // TODO: pascal case the value - need custom serialization fix though
            output("ENUM VALUE: " + ev.Value, DiagnosticSeverity.Info);
            sb.AppendLine($"    {ev.Value},");
        }
        sb.AppendLine("}");
        output("DONE ENUM COMPONENT GENERATING - " + enumName, DiagnosticSeverity.Info);
        
        return sb.ToString();
    }
    

    string GenerateObject(OpenApiSchema schema, string className)
    {
        output("===GENERATING CLASS COMPONENT: " + className, DiagnosticSeverity.Info);
        
        // Cache the schema for later use
        this.schemaCache[className] = schema;
        
        var sb = new StringBuilder();
        
        // Add JsonConverter attribute using fully qualified names only if enabled
        if (itemConfig.GenerateJsonConverters)
        {
            sb.AppendLine($"[global::System.Text.Json.Serialization.JsonConverterAttribute(typeof(global::{itemConfig.Namespace}.{className}JsonConverter))]");
        }
        
        sb
            // .AppendLine(Constants.GeneratedCodeAttributeString)
            .Append($"{this.accessorType} partial class " + className);

        // TODO: this will be 2 when discriminators are present
        //if (schema.Value.AllOf.Count > 1)
        //{
        //    Debugger.Launch();
        //}
        
        if ((schema.AllOf?.Count ?? 0) == 1)
        {
            // add inheritance
            var baseType = this.GetSchemaType(schema.AllOf!.Single());
            sb.AppendLine($" : {baseType}");

            output($"INHERITED: {className} ({baseType})", DiagnosticSeverity.Info);
        }
        sb.AppendLine();
        sb.AppendLine("{");
        
        if (schema.Properties != null)
        {
            foreach (var prop in schema.Properties)
            {
                var propertyName = prop.Key.Pascalize();
                string? typeName = null;

                if (prop.Value.Type == "object" && prop.Value.Properties != null && prop.Value.Reference == null)
                {
                    typeName = className + propertyName.Pascalize();
                    var add = this.GenerateObject(prop.Value, typeName);
                    this.typeBuilder.AppendLine(add);
                }
                else if ((prop.Value.Enum?.Count ?? 0) > 0 && prop.Value.Reference == null)
                {
                    typeName = className + propertyName.Pascalize();
                    var add = this.GenerateEnum(prop.Value, typeName);
                    this.typeBuilder.AppendLine(add);
                }
                else
                {
                    typeName = this.GetSchemaType(prop.Value);
                    if (typeName == null && (prop.Value.Enum?.Count ?? 0) > 0 && prop.Value.Reference != null)
                        typeName = prop.Value.Reference.Id;
                }

                if (typeName == null)
                {
                    output($"PROPERTY: {propertyName} - Type was not found", DiagnosticSeverity.Warning);
                }
                else
                {
                    // TODO: null when OneOf setup
                    // throw new InvalidOperationException("TypeName is null");
                    sb.AppendLine($"    [global::System.Text.Json.Serialization.JsonPropertyName(\"{prop.Key}\")]");
                    sb.AppendLine($"    public {typeName} {propertyName}"+ " { get; set; }");
                    sb.AppendLine();
                    output($"PROPERTY: {propertyName} ({typeName})", DiagnosticSeverity.Info);
                }
            }
        }

        sb.AppendLine("}");
        
        // Generate JSON converter immediately after the class if enabled
        if (itemConfig.GenerateJsonConverters)
        {
            sb.AppendLine();
            sb.Append(this.GenerateJsonConverterForType(className, schema));
        }
        
        output("===DONE GENERATING CLASS COMPONENT: " + className, DiagnosticSeverity.Info);
        return sb.ToString();
    }

    string GenerateJsonConverterForType(string typeName, OpenApiSchema schema)
    {
        var converterName = typeName + "JsonConverter";
        var sb = new StringBuilder();
        
        sb
            .AppendLine($"{this.accessorType} class {converterName} : global::System.Text.Json.Serialization.JsonConverter<global::{itemConfig.Namespace}.{typeName}>")
            .AppendLine("{")
            .AppendLine($"    public override global::{itemConfig.Namespace}.{typeName}? Read(ref global::System.Text.Json.Utf8JsonReader reader, global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)")
            .AppendLine("    {")
            .AppendLine("        if (reader.TokenType == global::System.Text.Json.JsonTokenType.Null)")
            .AppendLine("            return null;")
            .AppendLine()
            .AppendLine("        if (reader.TokenType != global::System.Text.Json.JsonTokenType.StartObject)")
            .AppendLine("            throw new global::System.Text.Json.JsonException(\"Expected StartObject token\");")
            .AppendLine()
            .AppendLine($"        var obj = new global::{itemConfig.Namespace}.{typeName}();")
            .AppendLine()
            .AppendLine("        while (reader.Read())")
            .AppendLine("        {")
            .AppendLine("            if (reader.TokenType == global::System.Text.Json.JsonTokenType.EndObject)")
            .AppendLine("                break;")
            .AppendLine()
            .AppendLine("            if (reader.TokenType != global::System.Text.Json.JsonTokenType.PropertyName)")
            .AppendLine("                throw new global::System.Text.Json.JsonException(\"Expected PropertyName token\");")
            .AppendLine()
            .AppendLine("            var propertyName = reader.GetString();")
            .AppendLine("            reader.Read();")
            .AppendLine()
            .AppendLine("            switch (propertyName)")
            .AppendLine("            {");
        
        // Generate property-specific deserialization
        foreach (var prop in schema.Properties)
        {
            var propType = this.GetSchemaType(prop.Value);
            var propertyName = prop.Key.Pascalize();

            sb.AppendLine($"                case \"{prop.Key}\":");

            if (propType != null)
            {
                this.GenerateReadLogicForProperty(sb, propertyName, propType, prop.Value);
            }
            else
            {
                sb.AppendLine("                    reader.Skip();");
            }
            sb.AppendLine("                    break;");
        }

        sb
            .AppendLine("                default:")
            .AppendLine("                    reader.Skip();")
            .AppendLine("                    break;")
            .AppendLine("            }")
            .AppendLine("        }")
            .AppendLine()
            .AppendLine("        return obj;")
            .AppendLine("    }")
            .AppendLine()
            .AppendLine($"    public override void Write(global::System.Text.Json.Utf8JsonWriter writer, global::{itemConfig.Namespace}.{typeName} value, global::System.Text.Json.JsonSerializerOptions options)")
            .AppendLine("    {")
            .AppendLine("        if (value == null)")
            .AppendLine("        {")
            .AppendLine("            writer.WriteNullValue();")
            .AppendLine("            return;")
            .AppendLine("        }")
            .AppendLine()
            .AppendLine("        writer.WriteStartObject();")
            .AppendLine();
        
        // Generate property-specific serialization
        foreach (var prop in schema.Properties)
        {
            var propType = this.GetSchemaType(prop.Value);
            var propertyName = prop.Key.Pascalize();

            if (propType != null)
            {
                this.GenerateWriteLogicForProperty(sb, prop.Key, propertyName, propType, prop.Value);
            }
        }

        sb
            .AppendLine("        writer.WriteEndObject();")
            .AppendLine("    }")
            .AppendLine("}");
        
        output($"GENERATED CONVERTER FOR: {typeName}", DiagnosticSeverity.Info);
        return sb.ToString();
    }

    void GenerateReadLogicForProperty(StringBuilder sb, string propertyName, string propType, OpenApiSchema propSchema)
    {
        var isNullable = propType.EndsWith("?");
        var baseType = isNullable ? propType.TrimEnd('?') : propType;
        
        if (propSchema.Type == "string")
        {
            if (isNullable)
            {
                sb.AppendLine("                    if (reader.TokenType == global::System.Text.Json.JsonTokenType.Null)");
                sb.AppendLine($"                        obj.{propertyName} = null;");
                sb.AppendLine("                    else");
                sb.AppendLine($"                        obj.{propertyName} = reader.GetString();");
            }
            else
            {
                sb.AppendLine($"                    obj.{propertyName} = reader.GetString() ?? string.Empty;");
            }
        }
        else if (propSchema.Type == "integer" || propSchema.Type == "number")
        {
            if (baseType == "int")
            {
                sb.AppendLine($"                    obj.{propertyName} = reader.GetInt32();");
            }
            else if (baseType == "long")
            {
                sb.AppendLine($"                    obj.{propertyName} = reader.GetInt64();");
            }
            else if (baseType == "float")
            {
                sb.AppendLine($"                    obj.{propertyName} = reader.GetSingle();");
            }
            else if (baseType == "double")
            {
                sb.AppendLine($"                    obj.{propertyName} = reader.GetDouble();");
            }
        }
        else if (propSchema.Type == "boolean")
        {
            sb.AppendLine($"                    obj.{propertyName} = reader.GetBoolean();");
        }
        else if (propSchema.Type == "array")
        {
            sb.AppendLine("                    if (reader.TokenType == global::System.Text.Json.JsonTokenType.StartArray)");
            sb.AppendLine("                    {");
            sb.AppendLine($"                        var list = new global::System.Collections.Generic.List<{this.GetSchemaType(propSchema.Items)}>();");
            sb.AppendLine("                        while (reader.Read() && reader.TokenType != global::System.Text.Json.JsonTokenType.EndArray)");
            sb.AppendLine("                        {");
            sb.AppendLine("                            var item = global::System.Text.Json.JsonSerializer.Deserialize(ref reader, typeof(" + this.GetSchemaType(propSchema.Items) + "), options);");
            sb.AppendLine("                            if (item != null) list.Add((" + this.GetSchemaType(propSchema.Items) + ")item);");
            sb.AppendLine("                        }");
            sb.AppendLine($"                        obj.{propertyName} = list;");
            sb.AppendLine("                    }");
        }
        else if (propType.StartsWith($"global::{itemConfig.Namespace}."))
        {
            // Custom type
            sb.AppendLine($"                    obj.{propertyName} = global::System.Text.Json.JsonSerializer.Deserialize<{propType}>(ref reader, options);");
        }
        else
        {
            // Fallback to generic deserialization
            sb.AppendLine($"                    obj.{propertyName} = global::System.Text.Json.JsonSerializer.Deserialize<{propType}>(ref reader, options);");
        }
    }

    void GenerateWriteLogicForProperty(StringBuilder sb, string jsonPropertyName, string propertyName, string propType, OpenApiSchema propSchema)
    {
        var isNullable = propType.EndsWith("?");
        
        if (isNullable)
        {
            sb.AppendLine($"        if (value.{propertyName} != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            writer.WritePropertyName(\"{jsonPropertyName}\");");
            this.GenerateWriteValueLogic(sb, propertyName, propType.TrimEnd('?'), propSchema, "            ");
            sb.AppendLine("        }");
        }
        else
        {
            sb.AppendLine($"        writer.WritePropertyName(\"{jsonPropertyName}\");");
            this.GenerateWriteValueLogic(sb, propertyName, propType, propSchema, "        ");
        }
        sb.AppendLine();
    }

    void GenerateWriteValueLogic(StringBuilder sb, string propertyName, string propType, OpenApiSchema propSchema, string indent)
    {
        if (propSchema.Type == "string")
        {
            sb.AppendLine($"{indent}writer.WriteStringValue(value.{propertyName});");
        }
        else if (propSchema.Type == "integer" || propSchema.Type == "number")
        {
            if (propType == "int")
            {
                sb.AppendLine($"{indent}writer.WriteNumberValue(value.{propertyName});");
            }
            else if (propType == "long")
            {
                sb.AppendLine($"{indent}writer.WriteNumberValue(value.{propertyName});");
            }
            else if (propType == "float")
            {
                sb.AppendLine($"{indent}writer.WriteNumberValue(value.{propertyName});");
            }
            else if (propType == "double")
            {
                sb.AppendLine($"{indent}writer.WriteNumberValue(value.{propertyName});");
            }
        }
        else if (propSchema.Type == "boolean")
        {
            sb.AppendLine($"{indent}writer.WriteBooleanValue(value.{propertyName});");
        }
        else if (propSchema.Type == "array")
        {
            sb.AppendLine($"{indent}writer.WriteStartArray();");
            sb.AppendLine($"{indent}if (value.{propertyName} != null)");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    foreach (var item in value.{propertyName})");
            sb.AppendLine($"{indent}        global::System.Text.Json.JsonSerializer.Serialize(writer, item, options);");
            sb.AppendLine($"{indent}}}");
            sb.AppendLine($"{indent}writer.WriteEndArray();");
        }
        else
        {
            // Custom type or complex object
            sb.AppendLine($"{indent}global::System.Text.Json.JsonSerializer.Serialize(writer, value.{propertyName}, options);");
        }
    }
}
